#include<all.H>
u8 xdata WS2812_Write_Buffer[Pixel_Data_Num];	//用于存储需要发送给WS2812灯的数据数组
												//Pixel_Data_Num=25，是因为总共8个灯
												//每个灯又有红绿蓝三种颜色，每个颜色就是一个数据
												//且对WS2812发送的第一个字节数据是无效的
												//故需要数据为3（3是三种颜色）*8（8是灯的数目）+1（1是无效数据）=25；
												
//***************************************************************************//
//               WS2812的初始化函数
//***************************************************************************//

void WS2812_Init()
{
	WS2812_DAT=1;				//WS2812_DAT是WS2812的DIN（数据输入脚），现在是P2^0口
								//在有数据输入的时候是置低 来 复位的，所以平时不用是拉高
}

//***************************************************************************//
//				WS2812发送数据函数
//***************************************************************************//

void WS2812_Write_Data(u8 *Point,u8 len)	//Point是一个指针指向WS2812_Write_Buffer[]这个数组，len是WS2812灯的个数
{											//WS2812_Write_Buffer[]这个数组的每一个数据都是对应灯珠的三种颜色亮点的数据
											//通过控制每个灯珠的三个颜色亮度的不同，使灯珠显示不同颜色
	u8 idata i,j,k,Value;
	for(i=0;i<len;i++)				//len是WS2812灯的个数，每个灯进行一次for()循环，发送每个灯的数据
	{
		for(j=0;j<3;j++)			//每个WS2812灯都有3种颜色，这个for()是使指针指向对应需要写入数据的颜色
		{
			switch(j)				//由于不同厂家的灯珠红绿蓝三种颜色排放顺序可能不同，故可以利用指针指向数组中对应灯珠的三种颜色亮点的数据，
									//就可以不用改变发送红绿蓝数据的顺序，来应对不同颜色顺序的灯珠
			{
				case 0:
						Value=*(Point+2);		//指针Point+2即是使指针指向某灯珠的第三个颜色，
						break;					//*(Point+2)是读取某灯珠的第三个颜色将其赋给Value，然后在下面的for()循环中发送给WS2812
				case 1:
						Value=*(Point);			//指针Point即是使指针指向某灯珠的第一个颜色，
						break;					//*(Point)是读取某灯珠的第一个颜色将其赋给Value，然后在下面的for()循环中发送给WS2812
				case 2:
						Value=*(Point+1);		//指针*(Point+1)即是使指针指向某灯珠的第二个颜色，
						break;					//*(Point+1)是读取某灯珠的第二个颜色将其赋给Value，然后在下面的for()循环中发送给WS2812
			}
			for(k=0;k<8;k++)					//每个颜色的数据是8位
			{
				if((Value&0x80)==0x80)			//Value是某个灯珠的某个颜色的亮度数据，Value&0x80，则结果不是为0x80,就是为0x00；
				{								//所以可以通过Value&0x80的结果来判断Value的最高位是1还是0，为1即0x80，为0即0x00
												//故若Value首位为1，则(Value&0x80)==0x80为真，即运行if里面的内容
												//也就是发送数据1给WS2812灯珠的DIN（数据输入脚）
					
					WS2812_DAT=1;				//由WS2812的数据手册可以知道：数据1即为先是高电平（大概0.85us左右），
												//然后是低电平（大概0.4us左右），一定要高电平时间>低电平时间，才是数据1
												//WS2812_DAT=1;就是将WS2812灯珠的DIN（数据输入脚）P2^0拉高
					_nop_();_nop_();_nop_();	//_nop_()是延迟是一个周期，使用前提是#include<intrins.h>头文件
					_nop_();_nop_();_nop_();	//使用多个_nop_();来起到控制延时间的作用，使高电平时间大于低电平时间
					_nop_();_nop_();_nop_();
					_nop_();_nop_();_nop_();
					_nop_();_nop_();
					Value<<=1;					//Value左移一位，使高位丢弃，次高位变成高位，为发送下一位数据做准备
					WS2812_DAT=0;				//WS2812_DAT=0即是DIN（数据输入脚）P2^0拉低，短的低电平配合上面长的高电平完成一位数据1的发送
					_nop_();					//此处只有一个_nop_()是因为单片机还要运行下面的程序所以，低电平存在的时间不止这一个周期
												//所以此处_nop_()不宜过多，否则低电平时间就可能大于高电平时间了，然后发送的数据就不是1，反而是0
				}
				else							//如果(Value&0x80)==0x80为假，即该位数据为0
				{								//发送数据0，即先发送高电平（大概0.4us），再发送低电平（大概0.85us），高电平时间<低电平时间，才是发送数据0
					WS2812_DAT=1;				//WS2812_DAT=1;就是将WS2812灯珠的DIN（数据输入脚）P2^0拉高
					_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();	//较短暂延时，使WS2812_DAT为高电平一段时间（大概0.4us）
					WS2812_DAT=0;												//WS2812_DAT=0;就是将WS2812灯珠的DIN（数据输入脚）P2^0拉低
					_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();_nop_();	//较长时间延时，虽然只比上面高电平多了一个_nop_()
																						//但是配合下面的程序，可以起到使WS2812_DAT较长时间为低电平
																						//经过上面使WS282_DAT较短的高电平，与较长的低电平后，
																						//就成功 的发送数据0了
					
					Value<<=1;															//Value左移一位使次高位变为最高位，以便发送后面的数据
				}
			}
		}
		Point+=3;					//Point是一个指针指向WS2812_Write_Buffer[]这个数组，
									//WS2812_Write_Buffer[]这个数组的每一个数据都是对应灯珠的三种颜色亮点的数据
									//故每一个灯珠占用数组中3个字节的数据
									//所以Point+=3是使指针Point指向下一个灯珠的第一个颜色的数据
	}
}

//***************************************************************//
//				WS2812显示数据
//***************************************************************//
void WS2812_Display_Ser()
{
	static xdata u8 count=0;
	if(count<100)						//对WS2812进行复位
	{
		WS2812_DAT=0;					//WS2812_DAT=0;是为了对WS2812进行复位，通过WS2812的数据手册可知
										//对DIN（数据输入脚）给予大于50us以上的低电平，就会复位
										//通过count++；使count在达到100之前保持DIN（数据输入脚）为低电平，进而达到复位效果
	}
	else								//在复位结束后向WS2812发送数据
	{
		EA=0;							//关闭中断，因为WS2812的数据是由高低电平配合完成的，
										//如果存在中断，可能会影响高低电平配比，使发送数据输错
		
		WS2812_Write_Data(WS2812_Write_Buffer+1,8);		//Point是一个指针指向WS2812_Write_Buffer[]这个数组的第二个数据
														//因为WS2812会舍弃第一个数据
														//因为有8个灯珠，所以len=8
		
		count=0;										//在此次数据发送完之后，将count=0，以便下一次发送数据前初始化	
		
		EA=1;											//开中断，以便中断相关程序继续进行
	}
	count++;											//count++，以便完成上面对DIN（数据输入脚）给予大于50us以上的低电平，达到复位效果
}